{"repository_name":"github.com/sstadick/crystal-lapper","body":"[![GitHub release](https://img.shields.io/github/release/sstadick/crystal-lapper.svg)](https://github.com/sstadick/lapper.cr/releases)\n[![Build Status](https://travis-ci.org/sstadick/crystal-lapper.svg?branch=master)](https://travis-ci.org/sstadick/lapper.cr)\n[![GitHub license](https://img.shields.io/github/license/sstadick/lapper.cr.svg)](https://github.com/sstadick/lapper.cr/blob/master/LICENSE)\n[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://GitHub.com/sstadick/lapper.cr/graphs/commit-activity)\n[![Docs](https://img.shields.io/badge/Documentation-yes-green.svg)](https://sstadick.github.io/lapper.cr/)\n\n# lapper.cr\n\nThis is a Crystal port of Brent Pendersen's [nim-lapper](https://github.com/brentp/nim-lapper). This crate works well for most genomic interval data. It does have a notable worst case scenario when very long regions engulf large percentages of the other intervals. As usual, you should benchmark on your expected data and see how it works.\n\n## Documentation\n\nSee [here](https://sstadick.github.io/lapper.cr/)\n\n## Installation\n\n1. Add the dependency to your `shard.yml`\n\n```yml\ndependencies:\n  lapper:\n    github: sstadick/lapper.cr\n```\n\n## Usage\n\n```crystal\nrequire \"lapper\"\n\n# Create some fake data\ndata = (0..100).step(by: 20).map { |x| Lapper::Interval(Int32).new(x, x + 10, 0) }.to_a\n\n# Create the lapper\nlapper = Lapper::Lapper(Int32).new(data)\n\n# Demo `find`\nlapper = Lapper::Lapper(Int32).new(data)\nlapper.find(5, 11).size == 2\n\n# Demo `seek` - calculate overlap between queries and the found intervals\nsum = 0\ncursor = 0\n(0..10).step(by: 3).each do |i|\n  sum += lapper.seek(i, i + 2).map { |iv| Math.min(i + 2, iv.stop) - Math.max(i, iv.start) }.sum\nend\nputs sum\n```\n\n## Performance\n\nHas not yet been benchmarked for the Crystal implementation. For other languages this library outperforms [all implementations](https://github.com/sstadick/rust-lapper#benchmarks) when the intervals are not heavily nested. For another Crystal implementation of an interval lib, see [klib.cr](https://github.com/lh3/biofast/blob/master/lib/klib.cr), which is based on the [cgranges](https://github.com/lh3/cgranges) lib by the same author.\n\n### Bench against klib\n\nBenchmarked against the klib.cr implementation and using the script found in `bench/biofast.cr` (uses the `find` with block method).\n\n```text\nBenchmark #1: ./bedcov_c1_cgr -c ../biofast-data-v1/ex-rna.bed ../biofast-data-v1/ex-anno.bed > bedcov_c1_cgr.out\n  Time (mean ± σ):      3.221 s ±  0.128 s    [User: 3.091 s, System: 0.122 s]\n  Range (min … max):    3.075 s …  3.423 s    10 runs\n\nBenchmark #2: ./bedcov_cr1_klib ../biofast-data-v1/ex-rna.bed ../biofast-data-v1/ex-anno.bed > bedcov_cr1_klib.out\n  Time (mean ± σ):      8.045 s ±  0.223 s    [User: 5.457 s, System: 2.688 s]\n  Range (min … max):    7.764 s …  8.440 s    10 runs\n\nBenchmark #3: bedcov_cr1_lapper/bin/bedcov_cr1_lapper ../biofast-data-v1/ex-rna.bed ../biofast-data-v1/ex-anno.bed > bedcov_cr1_lapper.out\n  Time (mean ± σ):      9.591 s ±  0.116 s    [User: 6.966 s, System: 2.751 s]\n  Range (min … max):    9.498 s …  9.835 s    10 runs\n\nSummary\n  './bedcov_c1_cgr -c ../biofast-data-v1/ex-rna.bed ../biofast-data-v1/ex-anno.bed > bedcov_c1_cgr.out' ran\n    2.50 ± 0.12 times faster than './bedcov_cr1_klib ../biofast-data-v1/ex-rna.bed ../biofast-data-v1/ex-anno.bed > bedcov_cr1_klib.out'\n    2.98 ± 0.12 times faster than 'bedcov_cr1_lapper/bin/bedcov_cr1_lapper ../biofast-data-v1/ex-rna.bed ../biofast-data-v1/ex-anno.bed > bedcov_cr1_lapper.out'\n```\n\n### `find` and `seek` variants on query data sorted by start\n\n```text\n      find  13.86  ( 72.17ms) (± 8.03%)  81.5MB/op   1.63× slower\n      seek  15.31  ( 65.33ms) (± 4.51%)  81.5MB/op   1.48× slower\nfind_yield  21.95  ( 45.57ms) (± 5.29%)  1.53MB/op   1.03× slower\nseek_yield  22.61  ( 44.23ms) (± 1.52%)  1.53MB/op        fastest\nfind_share  15.36  ( 65.08ms) (± 3.68%)  81.5MB/op   1.47× slower\nseek_share  15.52  ( 64.43ms) (± 4.30%)  81.5MB/op   1.46× slower\n```\n\nNote that for more queries than represented here, `seek` should get faster.\n\nThe `bench\\bench.cr` script is expecting the [this](https://github.com/lh3/biofast/releases/download/biofast-data-v1/biofast-data-v1.tar.gz) data to be in the top top level dir of the repo and untarred.\n\n\n## Contributing\n\n1. Fork it (<https://github.com/sstadick/lapper.cr/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Seth Stadick](https://github.com/sstadick) - creator and maintainer\n","program":{"html_id":"github.com/sstadick/crystal-lapper/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/sstadick/crystal-lapper","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/sstadick/crystal-lapper/Lapper","path":"Lapper.html","kind":"module","full_name":"Lapper","name":"Lapper","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lapper.cr","line_number":60,"url":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr"}],"repository_name":"github.com/sstadick/crystal-lapper","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"1.3.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"This module provides a simple data-structure for fast interval searches.\n## Features\n- Extremely fast on most genomic datasets.\n- Extremly fast on in order queries.\n\nExample query:\n```text\n      0  1  2  3  4  5  6  7  8  9  10 11\n(0,10]X  X  X  X  X  X  X  X  X  X\n(2,5]       X  X  X\n(3,8]          X  X  X  X  X\n(3,8]          X  X  X  X  X\n(3,8]          X  X  X  X  X\n(3,8]          X  X  X  X  X\n(5,9]                X  X  X  X\n(8,11]                        X  X  X\n\nQuery: (8, 11]\nAnswer: ((0,10], (5,9], (8,11])\n```\n\nMost interaction with this shard will be through the `Lapper` class.\nThe main methods are `Lapper#find` and `Lapper#seek`.\n\nThe overlap function for this assumes a zero based genomic coordinate system. So\n[start, stop) is not inclusive of the stop position for neither queries nor the\n`Intervals`.\n\nLapper does not use an interval tree, instead, it operates on the assumtion that most intervals are\nof similar length; or, more exactly, that the longest interval in the set is not long compred to\nthe average distance between intervals.\n\nFor cases where this holds true (as it often does with genomic data), we can sort by start and\nuse binary search on the starts, accounting for the length of the longest interval. The advantage\nof this approach is simplicity of implementation and speed. In realistic tests queries returning\nthe overlapping intervals are 1000 times faster than brute force and queries that merely check\nfor the overlaps are > 5000 times faster.\n\n# Examples\n```\nrequire \"lapper\"\n\n# Create some fake data\ndata = (0..100).step(by: 20).map { |x| Lapper::Interval(Int32).new(x, x + 10, 0) }.to_a\n\n# Create the lapper\nlapper = Lapper::Lapper(Int32).new(data)\n\n# Demo `find`\nlapper = Lapper::Lapper(Int32).new(data)\nlapper.find(5, 11).size == 2\n\n# Demo `seek` - calculate overlap between queries and the found intervals\nsum = 0\ncursor = 0\n(0..10).step(by: 3).each do |i|\n  sum += lapper.seek(i, i + 2).map { |iv| Math.min(i + 2, iv.stop) - Math.max(i, iv.start) }.sum\nend\n```","summary":"<p>This module provides a simple data-structure for fast interval searches.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/sstadick/crystal-lapper/Lapper/Interval","path":"Lapper/Interval.html","kind":"struct","full_name":"Lapper::Interval(T)","name":"Interval","abstract":false,"superclass":{"html_id":"github.com/sstadick/crystal-lapper/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"github.com/sstadick/crystal-lapper/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/sstadick/crystal-lapper/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"github.com/sstadick/crystal-lapper/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/sstadick/crystal-lapper/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lapper.cr","line_number":64,"url":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr"}],"repository_name":"github.com/sstadick/crystal-lapper","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/sstadick/crystal-lapper/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/sstadick/crystal-lapper/Lapper","kind":"module","full_name":"Lapper","name":"Lapper"},"doc":"Represent an interval that can hold a *val* of any type","summary":"<p>Represent an interval that can hold a <em>val</em> of any type</p>","class_methods":[],"constructors":[{"id":"new(start:Int32,stop:Int32,val:T)-class-method","html_id":"new(start:Int32,stop:Int32,val:T)-class-method","name":"new","doc":"Creates an `Interval`\n```\niv = Interval(String).new(5, 10, \"chr1\")\n```","summary":"<p>Creates an <code><a href=\"../Lapper/Interval.html\">Interval</a></code> <code></code>` iv = Interval(String).new(5, 10, \"chr1\") <code></code>`</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"},{"name":"val","doc":null,"default_value":"","external_name":"val","restriction":"T"}],"args_string":"(start : Int32, stop : Int32, val : T)","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L75","def":{"name":"new","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"},{"name":"val","doc":null,"default_value":"","external_name":"val","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Interval(T).allocate\n_.initialize(start, stop, val)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"(other:self)-instance-method","html_id":"(other:self)-instance-method","name":"<=>","doc":"Compare two intervals","summary":"<p>Compare two intervals</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"self"}],"args_string":"(other : <span class=\"k\">self</span>)","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L98","def":{"name":"<=>","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"self"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if @start < other.start\n  -1\nelse\n  if other.start < @start\n    1\n  else\n    @stop <=> other.stop\n  end\nend"}},{"id":"intersect(other:self):Int32-instance-method","html_id":"intersect(other:self):Int32-instance-method","name":"intersect","doc":"Compute the intersect between two intervals\n```\niv = Interval(Int32).new(0, 5, 0)\niv.intersect(Interval(Int32).new(4, 6, 0)) # => 1\n```","summary":"<p>Compute the intersect between two intervals <code></code>` iv = Interval(Int32).new(0, 5, 0) iv.intersect(Interval(Int32).new(4, 6, 0)) # => 1 <code></code>`</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"self"}],"args_string":"(other : <span class=\"k\">self</span>) : Int32","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L83","def":{"name":"intersect","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"self"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"intersect = (Math.min(@stop, other.stop)) - (Math.max(@start, other.start))\nintersect < 0 ? 0 : intersect\n"}},{"id":"overlap(start:Int32,stop:Int32):Bool-instance-method","html_id":"overlap(start:Int32,stop:Int32):Bool-instance-method","name":"overlap","doc":"Compute wheter self overlaps a range\n```\niv = Interval(Int32).new(0, 5, 0)\niv.overlap(4, 6) # => true\n```","summary":"<p>Compute wheter self overlaps a range <code></code>` iv = Interval(Int32).new(0, 5, 0) iv.overlap(4, 6) # => true <code></code>`</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"args_string":"(start : Int32, stop : Int32) : Bool","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L93","def":{"name":"overlap","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Bool","visibility":"Public","body":"@start < stop && @stop > start"}},{"id":"start-instance-method","html_id":"start-instance-method","name":"start","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L67","def":{"name":"start","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@start"}},{"id":"stop-instance-method","html_id":"stop-instance-method","name":"stop","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L68","def":{"name":"stop","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@stop"}},{"id":"val-instance-method","html_id":"val-instance-method","name":"val","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L69","def":{"name":"val","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@val"}}],"macros":[],"types":[]},{"html_id":"github.com/sstadick/crystal-lapper/Lapper/Lapper","path":"Lapper/Lapper.html","kind":"class","full_name":"Lapper::Lapper(T)","name":"Lapper","abstract":false,"superclass":{"html_id":"github.com/sstadick/crystal-lapper/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/sstadick/crystal-lapper/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/sstadick/crystal-lapper/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lapper.cr","line_number":114,"url":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr"}],"repository_name":"github.com/sstadick/crystal-lapper","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/sstadick/crystal-lapper/Lapper","kind":"module","full_name":"Lapper","name":"Lapper"},"doc":"Lapper is the primary data structure that contains the sorted Array of `Interval(T)`\n```\ndata = (0..100).step(by: 20).map { |x| Interval(Int32).new(x, x + 10, 0) }.to_a\nlapper = Lapper(Int32).new(data)\n```","summary":"<p>Lapper is the primary data structure that contains the sorted Array of <code><a href=\"../Lapper/Interval.html\">Interval</a>(T)</code> <code></code>` data = (0..100).step(by: 20).map { |x| Interval(Int32).new(x, x + 10, 0) }.to_a lapper = Lapper(Int32).new(data) <code></code>`</p>","class_methods":[],"constructors":[{"id":"new(intervals:Array(Lapper::Interval(T)),cursor:Int32=0,max_len:Int32=0)-class-method","html_id":"new(intervals:Array(Lapper::Interval(T)),cursor:Int32=0,max_len:Int32=0)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"intervals","doc":null,"default_value":"","external_name":"intervals","restriction":"Array(Interval(T))"},{"name":"cursor","doc":null,"default_value":"0","external_name":"cursor","restriction":"Int32"},{"name":"max_len","doc":null,"default_value":"0","external_name":"max_len","restriction":"Int32"}],"args_string":"(intervals : Array(Lapper::Interval(T)), cursor : Int32 = <span class=\"n\">0</span>, max_len : Int32 = <span class=\"n\">0</span>)","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L117","def":{"name":"new","args":[{"name":"intervals","doc":null,"default_value":"","external_name":"intervals","restriction":"Array(Interval(T))"},{"name":"cursor","doc":null,"default_value":"0","external_name":"cursor","restriction":"Int32"},{"name":"max_len","doc":null,"default_value":"0","external_name":"max_len","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Lapper(T).allocate\n_.initialize(intervals, cursor, max_len)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"find(start:Int32,stop:Int32,ivs:Array(Lapper::Interval(T)))-instance-method","html_id":"find(start:Int32,stop:Int32,ivs:Array(Lapper::Interval(T)))-instance-method","name":"find","doc":"Find all intervals that overlap start .. stop.\nReuses an passed in array.\n```\ndata = (0..100).step(by: 5).map { |x| Interval(Int32).new(x, x + 2, 0) }.to_a\nlapper = Lapper(Int32).new(data)\nlapper.find(5, 11, [] of Interval(Int32)).size == 2\n```","summary":"<p>Find all intervals that overlap start ..</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"},{"name":"ivs","doc":null,"default_value":"","external_name":"ivs","restriction":"Array(Interval(T))"}],"args_string":"(start : Int32, stop : Int32, ivs : Array(Lapper::Interval(T)))","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L170","def":{"name":"find","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"},{"name":"ivs","doc":null,"default_value":"","external_name":"ivs","restriction":"Array(Interval(T))"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if ivs.size != 0\n  ivs.clear\nend\noff = lower_bound(start - @max_len, @intervals)\nwhile off < @intervals.size\n  interval = @intervals.unsafe_fetch(off)\n  off = off + 1\n  if interval.overlap(start, stop)\n    ivs << interval\n  else\n    if interval.start >= stop\n      break\n    end\n  end\nend\n"}},{"id":"find(start:Int32,stop:Int32)-instance-method","html_id":"find(start:Int32,stop:Int32)-instance-method","name":"find","doc":"Find all intervals that overlap start .. stop.\nReturns a new array for each query.\n```\ndata = (0..100).step(by: 5).map { |x| Interval(Int32).new(x, x + 2, 0) }.to_a\nlapper = Lapper(Int32).new(data)\nlapper.find(5, 11).size == 2\n```","summary":"<p>Find all intervals that overlap start ..</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"args_string":"(start : Int32, stop : Int32)","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L148","def":{"name":"find","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"result = [] of Interval(T)\noff = lower_bound(start - @max_len, @intervals)\nwhile off < @intervals.size\n  interval = @intervals.unsafe_fetch(off)\n  off = off + 1\n  if interval.overlap(start, stop)\n    result << interval\n  else\n    if interval.start >= stop\n      break\n    end\n  end\nend\nresult\n"}},{"id":"find(start:Int32,stop:Int32,&)-instance-method","html_id":"find(start:Int32,stop:Int32,&amp;)-instance-method","name":"find","doc":"Find all intervals that overlap start .. stop.\nTakes a block that accepts an interval.\n```\ndata = (0..100).step(by: 5).map { |x| Interval(Int32).new(x, x + 2, 0) }.to_a\nlapper = Lapper(Int32).new(data)\ntotal = 0\nlapper.find(5, 11) { |iv| total += 1 }\ntotal # => 2\n```","summary":"<p>Find all intervals that overlap start ..</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"args_string":"(start : Int32, stop : Int32, &)","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L195","def":{"name":"find","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"off = lower_bound(start - @max_len, @intervals)\nwhile off < @intervals.size\n  interval = @intervals.unsafe_fetch(off)\n  off = off + 1\n  if interval.overlap(start, stop)\n    yield interval\n  else\n    if interval.start >= stop\n      break\n    end\n  end\nend\n"}},{"id":"intervals:Array(Lapper::Interval(T))-instance-method","html_id":"intervals:Array(Lapper::Interval(T))-instance-method","name":"intervals","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Array(Lapper::Interval(T))","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L115","def":{"name":"intervals","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Interval(T))","visibility":"Public","body":"@intervals"}},{"id":"seek(start:Int32,stop:Int32,ivs:Array(Lapper::Interval(T)))-instance-method","html_id":"seek(start:Int32,stop:Int32,ivs:Array(Lapper::Interval(T)))-instance-method","name":"seek","doc":"Find all intervals that overlap start .. stop when queries are in sorted (by start) order.\nThis variant adds to an array ref that is passed in.\n```\ndata = (0..100).step(by: 5).map { |x| Interval(Int32).new(x, x + 2, 0) }.to_a\nlapper = Lapper(Int32).new(data)\ncursor = 0\nivs = [] of Interval(Int32)\nlapper.intervals.each do |i|\n  lapper.seek(i.start, i.stop, ivs)\n  ivs.size == 1\nend\n```","summary":"<p>Find all intervals that overlap start ..</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"},{"name":"ivs","doc":null,"default_value":"","external_name":"ivs","restriction":"Array(Interval(T))"}],"args_string":"(start : Int32, stop : Int32, ivs : Array(Lapper::Interval(T)))","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L285","def":{"name":"seek","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"},{"name":"ivs","doc":null,"default_value":"","external_name":"ivs","restriction":"Array(Interval(T))"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if ivs.size != 0\n  ivs.clear\nend\nif ((@cursor == 0) || @cursor >= @intervals.size) || @intervals[@cursor].start > start\n  @cursor = lower_bound(start - @max_len, @intervals)\nend\nwhile (@cursor + 1) < @intervals.size && @intervals[@cursor + 1].start < (start - @max_len)\n  @cursor = @cursor + 1\nend\nc = @cursor\nwhile c < intervals.size\n  interval = @intervals.unsafe_fetch(c)\n  c = c + 1\n  if interval.overlap(start, stop)\n    ivs << interval\n  else\n    if interval.start >= stop\n      break\n    end\n  end\nend\n"}},{"id":"seek(start:Int32,stop:Int32)-instance-method","html_id":"seek(start:Int32,stop:Int32)-instance-method","name":"seek","doc":"Find all intervals that overlap start .. stop when queries are in sorted (by start) order.\nIt uses a linear search from the last query instead of a binary search. A reference to a\ncursor must be passed in. This reference will be modified and should be reused in the next\nquery. This allows seek to not need to make mutate the lapper itself and be useable across\nthreads.\n```\ndata = (0..100).step(by: 5).map { |x| Interval(Int32).new(x, x + 2, 0) }.to_a\nlapper = Lapper(Int32).new(data)\ncursor = 0\nlapper.intervals.each do |i|\n  lapper.seek(i.start, i.stop).size == 1\nend\n```","summary":"<p>Find all intervals that overlap start ..</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"args_string":"(start : Int32, stop : Int32)","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L221","def":{"name":"seek","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if ((@cursor == 0) || @cursor >= @intervals.size) || @intervals[@cursor].start > start\n  @cursor = lower_bound(start - @max_len, @intervals)\nend\nwhile (@cursor + 1) < @intervals.size && @intervals[@cursor + 1].start < (start - @max_len)\n  @cursor = @cursor + 1\nend\nresult = [] of Interval(T)\nc = @cursor\nwhile c < intervals.size\n  interval = @intervals.unsafe_fetch(c)\n  c = c + 1\n  if interval.overlap(start, stop)\n    result << interval\n  else\n    if interval.start >= stop\n      break\n    end\n  end\nend\nresult\n"}},{"id":"seek(start:Int32,stop:Int32,&)-instance-method","html_id":"seek(start:Int32,stop:Int32,&amp;)-instance-method","name":"seek","doc":"Find all intervals that overlap start .. stop when queries are in sorted (by start) order.\nThis variant takes a block that will be called for each found interval.\n```\ndata = (0..100).step(by: 5).map { |x| Interval(Int32).new(x, x + 2, 0) }.to_a\nlapper = Lapper(Int32).new(data)\ncursor = 0\nlapper.intervals.each do |i|\n  size = 0\n  lapper.seek(i.start, i.stop) { |iv| size += 1 }\n  size == 1\nend\n```","summary":"<p>Find all intervals that overlap start ..</p>","abstract":false,"args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"args_string":"(start : Int32, stop : Int32, &)","source_link":"https://github.com/sstadick/crystal-lapper/blob/edeb2b7e55332d0cb6a9e15f87c9584cd588c65e/src/lapper.cr#L254","def":{"name":"seek","args":[{"name":"start","doc":null,"default_value":"","external_name":"start","restriction":"Int32"},{"name":"stop","doc":null,"default_value":"","external_name":"stop","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"if ((@cursor == 0) || @cursor >= @intervals.size) || @intervals[@cursor].start > start\n  @cursor = lower_bound(start - @max_len, @intervals)\nend\nwhile (@cursor + 1) < @intervals.size && @intervals[@cursor + 1].start < (start - @max_len)\n  @cursor = @cursor + 1\nend\nc = @cursor\nwhile c < @intervals.size\n  interval = intervals.unsafe_fetch(c)\n  c = c + 1\n  if interval.overlap(start, stop)\n    yield interval\n  else\n    if interval.start >= stop\n      break\n    end\n  end\nend\n"}}],"macros":[],"types":[]}]}]}}